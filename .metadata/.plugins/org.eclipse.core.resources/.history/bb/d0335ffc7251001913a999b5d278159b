package dataStructures;

import java.util.NoSuchElementException;

public class BinarySearchTree<T extends Comparable<T>> extends BinaryTree<T>
{
	public void insert(T data)
	{
		SearchTreeNode<T> newNode = new SearchTreeNode<>(data);
		if(root == null)
			root = newNode;
		else
			root.add(newNode);
	}
	
	public boolean contains(T data)
	{
		if(root == null)
			return false;
		return ((SearchTreeNode<T>) root).contains(data);
	}
	
	public void remove(T data)
	{
		if(!contains(data))
			throw new NoSuchElementException();
		
		SearchTreeNode<T> node = ((SearchTreeNode<T>) root).find(data);
		SearchTreeNode<T> parent = ((SearchTreeNode<T>) root).findParent(node);
		boolean left = parent.getLeft() == node;
		
		int children = 0;
		if(node.getLeft() != null)
			children++;
		if(node.getRight() != null)
			children++;
		
		switch(children)
		{
			case 0:
				if(left)
					parent.setLeft(null);
				else
					parent.setRight(null);
				break;
			case 1:
				TreeNode<T> next = (node.getLeft() == null ? node.getRight() : node.getLeft());
				if(left)
					parent.setLeft(next);
				else
					parent.setRight(next);
				break;
			case 2:
//				SearchTreeNode<T> successor = ((SearchTreeNode<T>) node.getRight()).getMinimumNode();
				SearchTreeNode<T> successor = getInorderSuccessor(node);
//				SearchTreeNode<T> successor = ((SearchTreeNode<T>) root).getInorderSuccessor(node);
				SearchTreeNode<T> sParent = ((SearchTreeNode<T>) root).findParent(successor);
				
				if(node.getLeft() != successor)
					successor.setLeft(node.getLeft());
				if(node.getRight() != successor)
					successor.setLeft(node.getRight());
				
				if(sParent.getLeft() == successor)
					sParent.setLeft(null);
				else
					sParent.setRight(null);
				
				if(left)
					parent.setLeft(successor);
				else
					parent.setRight(successor);
				break;
		}
	}
	
	public boolean isValid()
	{
		return root == null || ((SearchTreeNode<T>) root).isValid();
	}
	
	public SearchTreeNode<T> getInorderSuccessor(SearchTreeNode<T> node)
	{
		LinkedListQueue<SearchTreeNode<T>> q = new LinkedListQueue<>();
		root.visitInorder(current -> q.enqueue((SearchTreeNode<T>) current));
		try
		{
			boolean found = false;
			while(true)
			{
				if(found)
					return q.dequeue();
				if(q.dequeue() == node)
					found = true;
			}
		}
		catch(NoSuchElementException e)
		{
			return null;
		}
	}
}
